{"version":3,"file":"tenderly.overwrites.js","sourceRoot":"/","sources":["src/tenderly/tenderly.overwrites.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChainId, ErrorCode } from '@lifi/types'\nimport { ethers } from 'ethers'\nimport memoizee from 'memoizee'\n\nimport { logger } from '@tenderlysim/logger'\nimport { LifiError } from '@tenderlysim/common'\n\nimport {\n  encodeContractStates,\n  getPublicTokenContract,\n  getTokenContract,\n} from './tenderly.api'\nimport {\n  TenderlyConfig,\n  knownAllowanceMappings,\n  knownBalanceMappings,\n  knownProxyTokens,\n} from './tenderly.config'\nimport { State } from './tenderly.types.contract'\n\nconst _getContractStates =\n  (tenderlyConfig: TenderlyConfig) =>\n  async (\n    chainId: ChainId,\n    tokenAddress: string\n  ): Promise<State[] | undefined> => {\n    let tokenContract = await getPublicTokenContract(chainId, tokenAddress)\n\n    // try project contract as fallback\n    if (tokenContract?.data?.states === undefined) {\n      tokenContract = await getTokenContract(tenderlyConfig)(\n        chainId,\n        tokenAddress\n      )\n    }\n\n    return tokenContract?.data?.states\n  }\n\nconst getContractStates = memoizee(_getContractStates, {\n  promise: true,\n  maxAge: 60 * 60 * 1000, // 1h\n})\n\nconst getApprovalMapping = (\n  tokenImplementationAddress: string,\n  tokenStates: State[],\n  params: {\n    ownerAddress: string\n    spenderAddress: string\n    amount: string\n  }\n) => {\n  const mask = tokenStates\n    .map(({ type, name }) => {\n      if (knownAllowanceMappings[type]?.names.includes(name)) {\n        return name + knownAllowanceMappings[type].mask\n      }\n    })\n    .find((mask) => mask)\n\n  if (mask === undefined) {\n    logger().warn(\n      {\n        service: 'getApprovalMapping',\n        data: tokenStates,\n      },\n      `Unknown approval mapping for token ${tokenImplementationAddress}`\n    )\n    throw LifiError({\n      message: `Unable to find matching mapping in knownAllowanceMappings.`,\n      code: ErrorCode.NotProcessableError,\n    })\n  }\n  const mapping = mask\n    .replace('OWNER_ADDRESS', params.ownerAddress)\n    .replace('SPENDER_ADDRESS', params.spenderAddress)\n\n  return {\n    [mapping]: params.amount,\n  }\n}\n\nconst getBalanceMapping = (\n  tokenImplementationAddress: string,\n  tokenStates: State[],\n  params: {\n    ownerAddress: string\n    amount: string\n  }\n) => {\n  const mask = tokenStates\n    .map(({ type, name }) => {\n      if (knownBalanceMappings[type]?.names.includes(name)) {\n        return name + knownBalanceMappings[type].mask\n      }\n    })\n    .find((mask) => mask)\n\n  if (mask === undefined) {\n    logger().warn(\n      {\n        service: 'getBalanaceMapping',\n        data: tokenStates,\n      },\n      `Unknown balance mapping for token ${tokenImplementationAddress}`\n    )\n    throw LifiError({\n      message: `Unable to find matching mapping in knownBalanceMappings.`,\n      code: ErrorCode.NotProcessableError,\n    })\n  }\n  const mapping = mask.replace('OWNER_ADDRESS', params.ownerAddress)\n\n  return {\n    [mapping]: params.amount,\n  }\n}\n\nexport const getTokenOverwrite =\n  (tenderlyConfig: TenderlyConfig) =>\n  async (params: {\n    chainId: number\n    tokenAddress: string\n    amount: string\n    ownerAddress: string\n    spenderAddress: string\n  }) => {\n    if (params.tokenAddress === ethers.ZeroAddress) {\n      return {}\n    }\n\n    // use proxy implementation if available\n    let tokenImplementationAddress =\n      params.tokenAddress.toLowerCase() as Lowercase<string>\n    if (knownProxyTokens[params.chainId]?.[tokenImplementationAddress]) {\n      tokenImplementationAddress =\n        knownProxyTokens[params.chainId][tokenImplementationAddress]\n    }\n\n    const contractStates = await getContractStates(tenderlyConfig)(\n      params.chainId,\n      tokenImplementationAddress\n    )\n    if (contractStates === undefined) {\n      throw LifiError({\n        message: `Unable to find contract states.`,\n        code: ErrorCode.ThirdPartyError,\n      })\n    }\n\n    const approvalMapping = getApprovalMapping(\n      tokenImplementationAddress,\n      contractStates,\n      params\n    )\n    const balanceMapping = getBalanceMapping(\n      tokenImplementationAddress,\n      contractStates,\n      params\n    )\n    const rawState: Record<string, string> = ({} = {\n      ...approvalMapping,\n      ...balanceMapping,\n    })\n\n    return encodeContractStates(tenderlyConfig)(\n      params.chainId,\n      params.tokenAddress,\n      tokenImplementationAddress,\n      rawState\n    )\n  }\n"]}